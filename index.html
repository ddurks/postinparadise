<!DOCTYPE html>
<html lang="en">
	<head>
		<title>post in paradise</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<script async src="https://unpkg.com/suncalc@1.8.0/suncalc.js"></script>
	</head>
	<body>
		<img id="loading" src="textures/loading.gif">
		<div id="container"></div>
		<div id="info">
			<a href="http://postinparadise.com" target="_blank" rel="noopener">post in paradise</a>
		</div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../lib/three.module.js",
					"three/addons/": "./jsm/",
					"suncalc": "../lib/suncalc.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { Water } from 'three/addons/objects/Water.js';
			import { Sky } from 'three/addons/objects/Sky.js';

			import { GLTFLoader } from "https://unpkg.com/three@0.139.0/examples/jsm/loaders/GLTFLoader.js";

			let container, stats;
			let camera, scene, renderer;
			var raycaster, gravityRaycaster, gravityDirection;
			let controls, sky, water, sun;
			let lat = 41.881832, long = -87.623177,phi, theta;
			let sunPos, sunAzimuth, sunAltitude, parameters, renderTarget, pmremGenerator;
			var movieScreen, loginButton;
			var today = new Date();
			let currMinutes = today.getMinutes();
			var crab, island;
			var time = 0;
			var animationsMap = new Map(), crabMixer, clock;

			let walkTime = 0; // Time variable for walking
			var walkPath = [];

			let userLocation = navigator.geolocation;
			function myGeolocator() {
				if(userLocation) {
					userLocation.getCurrentPosition(success);
				} else {
					console.log("The geolocation API is not supported by your browser.");
				}
			}
			function success(data) {
				lat = data.coords.latitude;
				long = data.coords.longitude;
				updateSun();
			}

			myGeolocator();

			init();
			THREE.DefaultLoadingManager.onLoad = () => {
				document.getElementById("loading").outerHTML = "";
				animate();
			};

			function init() {

				container = document.getElementById( 'container' );

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 0.5;
				container.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 0, 4, 40 );

				sun = new THREE.Vector3();

				// Set up raycaster for detecting the surface position
				raycaster = new THREE.Raycaster();
				gravityRaycaster = new THREE.Raycaster();

				gravityDirection = new THREE.Vector3(0, -1, 0);

				clock = new THREE.Clock();
				walkPath = createWalkPath();

				// Water

				const waterGeometry = new THREE.PlaneGeometry( 10000, 10000 );

				water = new Water(
					waterGeometry,
					{
						textureWidth: 512,
						textureHeight: 512,
						waterNormals: new THREE.TextureLoader().load( 'textures/waternormals.jpg', function ( texture ) {

							texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

						} ),
						sunDirection: new THREE.Vector3(),
						sunColor: 0xffffff,
						waterColor: 0x001e0f,
						distortionScale: 3.7,
						fog: scene.fog !== undefined
					}
				);

				water.rotation.x = - Math.PI / 2;

				scene.add( water );

				// Skybox

				sky = new Sky();
				sky.scale.setScalar( 10000 );
				scene.add( sky );

				// const axesHelper = new THREE.AxesHelper( 5 );
				// axesHelper.position.set(0, 10, 0);
				// scene.add( axesHelper );

				const skyUniforms = sky.material.uniforms;

				skyUniforms[ 'turbidity' ].value = 10;
				skyUniforms[ 'rayleigh' ].value = 2;
				skyUniforms[ 'mieCoefficient' ].value = 0.005;
				skyUniforms[ 'mieDirectionalG' ].value = 0.8;

				// Meshes
				var gltfLoader = new GLTFLoader();
				var leaves, tree;
				var islandX = 0, islandY = 0, islandZ = 0;
				gltfLoader.load("./glb/paradise.glb", (gltf) => {
					gltf.scene.traverse(function (object) {
						if (object.isMesh) object.castShadow = true;
					});
					leaves = gltf.scene.getObjectByName('Armature');
					leaves.position.set(islandX, islandY + 8.5, islandZ);
					scene.add( leaves );
					tree = gltf.scene.getObjectByName('tree');
					tree.position.set(islandX - 1, islandY + 5, islandZ);
					scene.add( tree );
					island = gltf.scene.getObjectByName('island');
					island.position.set(islandX, islandY - 0.6, islandZ);
					island.scale.set(5,2,5);
					scene.add( island );
				});
				gltfLoader.load("./glb/screencrab.glb", (gltf) => {
					gltf.scene.traverse(function (object) {
						if (object.isMesh) object.castShadow = true;
					});
					crab = gltf.scene.getObjectByName('Armature');
					crab.position.set(islandX + 1, islandY + 10, islandZ + 1);
					scene.add( crab );

					crabMixer = new THREE.AnimationMixer(crab);
					gltf.animations.forEach((a) => {
						animationsMap.set(a.name, crabMixer.clipAction(a));
					});
					animationsMap.get('walk').fadeIn(1).play();
				});

				pmremGenerator = new THREE.PMREMGenerator( renderer );
				let renderTarget;

				controls = new OrbitControls( camera, renderer.domElement );
				controls.maxPolarAngle = Math.PI * 0.495;
				controls.target.set( 0, 3, 0 );
				controls.minDistance = 5;
				controls.maxDistance = 200.0;
				controls.update();

				stats = new Stats();
				container.appendChild( stats.dom );

				updateSun();				

				window.addEventListener( 'resize', onWindowResize );

			}

			function getRandomInt(min, max) {
				min = Math.ceil(min);
				max = Math.floor(max);
				return Math.floor(Math.random() * (max - min + 1)) + min;
			}

			function updateSun() {
				sunPos = SunCalc.getPosition(new Date(), lat, long);
				sunAzimuth = sunPos.azimuth * 180 / Math.PI;
				sunAltitude = sunPos.altitude * 180 / Math.PI;
				parameters = {
					elevation: sunAltitude,
					azimuth: sunAzimuth
				};

				phi = THREE.MathUtils.degToRad( 90 - parameters.elevation );
				theta = THREE.MathUtils.degToRad( parameters.azimuth );

				sun.setFromSphericalCoords( 1, phi, theta );

				sky.material.uniforms[ 'sunPosition' ].value.copy( sun );
				water.material.uniforms[ 'sunDirection' ].value.copy( sun ).normalize();

				if ( renderTarget !== undefined ) renderTarget.dispose();

				renderTarget = pmremGenerator.fromScene( sky );

				scene.environment = renderTarget.texture;

			}

			function getRandomInRange(min, max) {
				return Math.random() * (max - min) + min;
			}

			function createWalkPath() {
				const stops = 3;
				const range = 7;

				let newPath = [];
				for(let i = 0; i < stops; i++){
					newPath.push({ x: getRandomInRange(-range, range), z: getRandomInRange(-range, range) })
				}
				return newPath;
			}

			function resetWalkPath() {
				let finalElement = { x: walkPath[walkPath.length - 1].x, z: walkPath[walkPath.length - 1].z };
				if (walkPath) {
					walkPath = createWalkPath();
					walkPath[0] = finalElement;
				}
			}

			function crabWalk(delta) {
				// Simulate walking along the defined path
				const walkSpeed = 0.005; // Adjust the speed of walking here

				if (walkTime >= 1) {
					walkTime = 0; // Restart walking
					resetWalkPath();
				} else {
					walkTime += walkSpeed;
				}

				// Interpolate the position along the path
				const currentWalkIndex = Math.floor(walkTime * (walkPath.length - 1));
				const nextWalkIndex = currentWalkIndex + 1;
			
				const t = walkTime * (walkPath.length - 1) - currentWalkIndex;

				const currentPos = walkPath[currentWalkIndex];
				let nextPos = walkPath[nextWalkIndex];
				if (!nextPos) {
					nextPos = currentPos;
				}

				const xPos = currentPos.x + (nextPos.x - currentPos.x) * t;
				const zPos = currentPos.z + (nextPos.z - currentPos.z) * t;
				crab.position.set(xPos, crab.position.y, zPos);

				// Calculate the angle between current and next positions
				const deltaX = nextPos.x - currentPos.x;
				const deltaZ = nextPos.z - currentPos.z;
				const angle = Math.atan2(deltaZ, deltaX);

				// Convert the angle to Euler angles and set the object's rotation
				const euler = new THREE.Euler(0, -angle + Math.PI / 2, 0);
				crab.rotation.copy(euler);
			}

			function updateCrab(delta) {
				crabWalk();

				// Set up raycaster to detect the position on the surface
				raycaster.set(crab.position, new THREE.Vector3(0, -1, 0)); // Pointing downward

				// Intersect the ray with the surface
				const intersects = raycaster.intersectObject(island);

				if (intersects.length > 0) {
					const intersectionPoint = intersects[0].point;
					crab.position.set(crab.position.x, intersectionPoint.y + 0.45, crab.position.z);
				}

				crabMixer.update(delta);
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {
				let delta = clock.getDelta();
				requestAnimationFrame( animate );
				render();
				stats.update();
				var today = new Date();
				let minutes = today.getMinutes();
				if (minutes !== currMinutes) {
					updateSun();
					currMinutes = minutes;
				}
				if (crab && island) {
					updateCrab(delta);
				}
			}

			function render() {

				const time = performance.now() * 0.001;

				water.material.uniforms[ 'time' ].value += 1.0 / 60.0;

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
