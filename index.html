<!DOCTYPE html>
<html lang="en">
	<head>
		<title>post in paradise</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<script src="https://unpkg.com/suncalc@1.8.0/suncalc.js"></script>
		<script src="lib/heightfield.worker.js"></script>
		<script src="lib/HeightfieldClient.js"></script>
	</head>
	<body>
		<img id="loading" src="textures/loading.gif">
		<div id="container"></div>
		<div id="info">
			<a href="http://postinparadise.com" target="_blank" rel="noopener">post in paradise</a>
		</div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../lib/three.module.js",
					"three/addons/": "./jsm/",
					"suncalc": "../lib/suncalc.js",
					"cannon": "./lib/cannon-es.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import * as CANNON from 'cannon';

			import Stats from 'three/addons/libs/stats.module.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { Water } from 'three/addons/objects/Water.js';
			import { Sky } from 'three/addons/objects/Sky.js';

			import { GLTFLoader } from "https://unpkg.com/three@0.139.0/examples/jsm/loaders/GLTFLoader.js";

			let container, stats;
			let camera, scene, renderer;
			let controls, sky, water, sun;
			let lat = 41.881832, long = -87.623177,phi, theta;
			let sunPos, sunAzimuth, sunAltitude, parameters, renderTarget, pmremGenerator;
			var movieScreen, loginButton;
			var today = new Date();
			let currMinutes = today.getMinutes();
			var treeMixer, crabMixer;
			let lt = new Date(),frame = 0;
			const maxFrame = 800,fps = 30;
			var leaves, island, tree, crab;
			var crabBody;
			var heightfieldClient = new HeightfieldClient();

			// PHYSICS
			const world = new CANNON.World();
			// Tweak contact properties.
			// Contact stiffness - use to make softer/harder contacts
			world.defaultContactMaterial.contactEquationStiffness = 1e9;
			// Stabilization time in number of timesteps
			world.defaultContactMaterial.contactEquationRelaxation = 4;
			const solver = new CANNON.GSSolver();
			solver.iterations = 7;
			solver.tolerance = 0.1;
			world.solver = new CANNON.SplitSolver(solver);
			// use this to test non-split solver
			// world.solver = solver
			world.gravity.set(0, -20, 0)
			// Create a contact material (friction coefficient = 0.3a)
			var physicsMaterial = new CANNON.Material('physics');
			const physics_physics = new CANNON.ContactMaterial(physicsMaterial, physicsMaterial, {
				friction: 0.3,
				restitution: 0.0,
			});
			// We must add the contact materials to the world
			world.addContactMaterial(physics_physics);

			let userLocation = navigator.geolocation;
			function myGeolocator() {
				if(userLocation) {
					userLocation.getCurrentPosition(success);
				} else {
					console.log("The geolocation API is not supported by your browser.");
				}
			}
			function success(data) {
				lat = data.coords.latitude;
				long = data.coords.longitude;
				updateSun();
			}

			myGeolocator();

			init();
			THREE.DefaultLoadingManager.onLoad = () => {
				document.getElementById("loading").outerHTML = "";
				animate();
			};

			function init() {

				container = document.getElementById( 'container' );

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 0.5;
				container.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 0, 4, 40 );

				sun = new THREE.Vector3();

				// Water

				const waterGeometry = new THREE.PlaneGeometry( 10000, 10000 );

				water = new Water(
					waterGeometry,
					{
						textureWidth: 512,
						textureHeight: 512,
						waterNormals: new THREE.TextureLoader().load( 'textures/waternormals.jpg', function ( texture ) {

							texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

						} ),
						sunDirection: new THREE.Vector3(),
						sunColor: 0xffffff,
						waterColor: 0x001e0f,
						distortionScale: 3.7,
						fog: scene.fog !== undefined
					}
				);

				water.rotation.x = - Math.PI / 2;

				scene.add( water );

				// Skybox

				sky = new Sky();
				sky.scale.setScalar( 10000 );
				scene.add( sky );

				const skyUniforms = sky.material.uniforms;

				skyUniforms[ 'turbidity' ].value = 10;
				skyUniforms[ 'rayleigh' ].value = 2;
				skyUniforms[ 'mieCoefficient' ].value = 0.005;
				skyUniforms[ 'mieDirectionalG' ].value = 0.8;

				var animationsMap = new Map();
				// Meshes
				var gltfLoader = new GLTFLoader();
				var islandX = 0, islandY = 0, islandZ = 0;
				gltfLoader.load("./glb/paradise.glb", (gltf) => {
					gltf.scene.traverse(function (object) {
						if (object.isMesh) object.castShadow = true;
					});
					leaves = gltf.scene.getObjectByName('Armature');
					leaves.position.set(islandX, islandY + 8.5, islandZ);
					scene.add( leaves );
					tree = gltf.scene.getObjectByName('tree');
					tree.position.set(islandX - 1, islandY + 5, islandZ);
					scene.add( tree );
					island = gltf.scene.getObjectByName('island');
					island.position.set(islandX, islandY - 0.6, islandZ);
					island.scale.set(5,2,5);
					scene.add( island );

					var heightfield = heightfieldClient.buildHeightField(island)
				});
				gltfLoader.load("./glb/screencrab.glb", (gltf) => {
					gltf.scene.traverse(function (object) {
						if (object.isMesh) object.castShadow = true;
					});
					crab = gltf.scene.getObjectByName('Armature');
					crab.position.set(islandX + 1, islandY + 5.9, islandZ + 1);
					scene.add( crab );

					const slipperyMaterial = new CANNON.Material('slippery');
					slipperyMaterial.friction = 0;

					// Player physics body
					const shape = new CANNON.Box(new CANNON.Vec3(1, 1, 1));
					crabBody = new CANNON.Body({
						mass: 1,
						material: slipperyMaterial
					});
					crabBody.addShape(shape);
					crabBody.position.copy(crab.position);
					crabBody.lastPosition = { x: crabBody.position.x, y: crabBody.position.y, z: crabBody.position.z };
					crabBody.linearDamping = 0.999;
					world.addBody(crabBody);

					crabMixer = new THREE.AnimationMixer(crab);
					gltf.animations.forEach((a) => {
						animationsMap.set(a.name, crabMixer.clipAction(a));
					});
					animationsMap.get('idle').fadeIn(2).play();
				});

				pmremGenerator = new THREE.PMREMGenerator( renderer );
				let renderTarget;

				controls = new OrbitControls( camera, renderer.domElement );
				controls.maxPolarAngle = Math.PI * 0.495;
				controls.target.set( 0, 3, 0 );
				controls.minDistance = 5;
				controls.maxDistance = 200.0;
				controls.update();

				stats = new Stats();
				container.appendChild( stats.dom );

				updateSun();				

				window.addEventListener( 'resize', onWindowResize );

			}

			function getRandomInt(min, max) {
				min = Math.ceil(min);
				max = Math.floor(max);
				return Math.floor(Math.random() * (max - min + 1)) + min;
			}

			function updateSun() {
				sunPos = SunCalc.getPosition(new Date(), lat, long);
				sunAzimuth = sunPos.azimuth * 180 / Math.PI;
				sunAltitude = sunPos.altitude * 180 / Math.PI;
				parameters = {
					elevation: sunAltitude,
					azimuth: sunAzimuth
				};

				phi = THREE.MathUtils.degToRad( 90 - parameters.elevation );
				theta = THREE.MathUtils.degToRad( parameters.azimuth );

				sun.setFromSphericalCoords( 1, phi, theta );

				sky.material.uniforms[ 'sunPosition' ].value.copy( sun );
				water.material.uniforms[ 'sunDirection' ].value.copy( sun ).normalize();

				if ( renderTarget !== undefined ) renderTarget.dispose();

				renderTarget = pmremGenerator.fromScene( sky );

				scene.environment = renderTarget.texture;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function crabUpdate(delta) {
				crab.position.copy(crabBody.position);
    			crabBody.quaternion.copy(crab.quaternion);
				world.step(timeStep, delta);
			}

			const clock = new THREE.Clock();
			const timeStep = 1/60;
			function animate() {

				requestAnimationFrame( animate );
				render();
				let delta = clock.getDelta();
				if (crabMixer) {
					crabMixer.update(delta);
					if (island && crab) {
						crabUpdate(delta);
					}
				}
				stats.update();
				var today = new Date();
				let minutes = today.getMinutes();
				if (minutes !== currMinutes) {
					updateSun();
					currMinutes = minutes;
				}
			}


			function render() {

				const time = performance.now() * 0.001;

				water.material.uniforms[ 'time' ].value += 1.0 / 60.0;

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
